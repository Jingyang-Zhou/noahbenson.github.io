
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Documentation for the Pimms Library &#8212; Pimms 0.2.3 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="documentation-for-the-pimms-library">
<h1>Documentation for the Pimms Library<a class="headerlink" href="#documentation-for-the-pimms-library" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<span class="target" id="module-pimms"></span><p>The pimms library is an immutable data-structure toolkit. It works primarily by decorators applied
to classes and their members to declare how an immutable data-structure’s members are related.
Taken together, these decorators form a DSL-like system for declaring immutable data-structures with
full inheritance support.</p>
<p>An immutable data-structure is simply a class that has been modified by the &#64;immutable decorator.
Inside an immutable class, a few things can be declared normally while others must be declared via
the special immutable syntax.
Things that can be delcared normally in an immutable class:</p>
<blockquote>
<div><ul class="simple">
<li>Instance methods of the class (def some_method(self, arg): …)</li>
<li>Static methods of the class (using &#64;staticmethod)</li>
<li>Static members of the class (some_class_member = 10)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Things that cannot be declared normally in an immutable class:</dt>
<dd><ul class="first last simple">
<li>All member variables of a class instance (usually assigned in __init__)</li>
<li>__new__, __setattr__, __getattribute__, __delattr__, __copy__, and __deepcopy__ cannot be
overloaded in immutable classes; doing so will result in undefined behavior</li>
<li>Immutable classes should generally only inherit from object or other immutable classes;
inheritance with other non-immutable classes is fine in theory, especially if only methods are
added to the class, but member access from immutable objects to non-immutable class members is
beyond the scope of this library.</li>
</ul>
</dd>
</dl>
<p>Immutable instance member variables, which are usually simply assigned in the class’s __init__
method, must be declared specially in immutable classes. All immutable instance members fall into
one of two categories: parameters and values. Parameters are values that must be assigned by the
end of the object’s __init__ function, in order for the object to be valid (an exception is raised
if these are not filled). Options are a special kind of parameter that also have default values in
case no assignment is given. Values, unlike parameters, can never be assigned directly; instead,
they are lazily and automatically calculated by a user-provided function of zero or more other
members of the class. Values may depend on either parameters or other values as long as there is
not a circular dependency graph implicit in the declarations.</p>
<p>All such instance member declarations are made using the &#64;param, &#64;option, &#64;value, and &#64;require
decorators, documented briefly here. In all four cases, &#64;param, &#64;option(&lt;default value&gt;), &#64;value,
and &#64;require, the decorator should precede a static function definition.</p>
<blockquote>
<div><ul class="simple">
<li>&#64;param declares two things: first, that the name of the static function that follows it is an
instance member and required parameter of the class and, second, that the static function
itself, which must take exactly one argument, should be considered a translation function on
any value assigned to the object; the return value of the function is the value actually
assigned to the object before any checks are run.</li>
<li>&#64;option(&lt;default value&gt;) is identical to &#64;param except that it declares that the given default
value should be used if no value is assigned to the object in the __init__ method. This value,
if it is used, is not passed through the translation function that follows.</li>
<li>&#64;value declares three things: first, that the name of the static function that follows it is an
instance member and (lazy) value of the class; second, that the arguments to that static
function, which must be named exactly after other instance members of the class, are instance on
members on which this value depends (thus this value will be reset when those members change);
and third, that the return value of that static function, when given the appropriate member
values, should be the value assigned to the instance member when requested.</li>
<li>&#64;require declares three things: first, that the name of the following static function is the
identifier for a particular requirement check on the instance members of any object of this
class; second, that the parameters of that static function, which must match exactly the names
of other instance members of the class, are the instance members that this requirement checks;
and third, that the static function’s return value will be True if and only if the check is
passed. The requirement function may throw its own exception or return False, in which case a
generic exception is raised.</li>
</ul>
</div></blockquote>
<p>All four decorator types may be overloaded in immutable child classes. Overloading works much as it
does with normal methods; only the youngest child-class’s method is required. This can be used to
overload requirements, but new requirements can be placed to act as additional constraints; i.e.,
the youngest class’s requirement is always run for all requirements in an object’s entire class
hierarchy when a relevant instance members is updated. Overloading may also be used to change an
instance member’s type in the child class, such as from a value to a parameter or vice versa. The
child class must, of course, be free of circular dependencies despite these rearrangements.</p>
<p>Note that a required parameter may be implied by the other instance member declarations; this is not
an error and instead inserts the parameter into the class automatically with no translation
function. This occurs when either a value or a requirement declares the parameter as an argument
but no instance member with the parameter’s name appears elsewhere in the class or its ancestor
classes. This can be used to create a sort of abstract immutable base class, in that a class may
declare a requirement of some parameter that is not otherwise defined; in order to instantiate the
class, that parameter must be given, either in a child class’s __init__ method or as a value or an
explicit (required or optional) parameter.</p>
<p>When an immutable object is constructed, it begins its life in a special ‘init’ state; this state is
unique in that no requirement checks are run until either the __init__ method returns or a value is
requested of the object; at that point, all non-optional parameters must be specified or an
exception is raised. If all parameters were set, then all requirement checks are run and the
object’s state shifts to ‘transient’. An immutable object imm can be tested for transience by using
the method imm.is_transient(). A transient object allows its parameters (but never its values) to be
set using normal setattr (imm.x = y) syntax. Requirement checks that are related to a parameter are
changed every time that parameter is set, after the translation function for that parameter is used.
An immutable object remains in the transient state until it is persisted via the imm.persist()
method. Once an object is persistent, it cannot be updated via setattr mechanisms and should be
considered permanent. A new transient duplicate of the object may be created using the
imm.transient() method (this may also be used while the object is still transient). To update the
values of an immutable object, the imm.copy(param1=val1, param2=val2, …) method should be used.
This method returns a persistent duplicate of the immutable object imm with the given parameters
updated to the given values; these values are always passed through the translation functions
and all relevant chacks are run prior to the return of the copy function. The copy function may
be called on transient or persistent immutables, but the return value is always peresistent.</p>
<dl class="docutils">
<dt>The additional utility functions are provided as part of the pimms package:</dt>
<dd><ul class="first last simple">
<li>is_imm(x) yields True if x is an object that is an instance of an immutable class and False
otherwise.</li>
<li>is_imm_type(x) yields True if x is a class that is immutable and False otherwise.</li>
<li>imm_copy(imm, …) is identical to imm.copy(…) for an immutable object imm.</li>
<li>imm_persist(imm) is identical to imm.persist() for a transient immutable object imm.</li>
<li>imm_transient(imm) is identical to imm.transient() for an immutable object imm.</li>
<li>imm_values(imm_t) yields a list of the values of the immutable class imm_t.</li>
<li>imm_params(imm_t) yields a list of the parameters of the immutable class imm_t.</li>
<li>imm_dict(imm) is identical to imm.asdict() for an immutable object imm.</li>
<li>imm_is_persistent(imm) is identical to imm.is_persistent() for an immutable object imm.</li>
<li>imm_is_transient(imm) is identical to imm.is_transient() for an immutable object imm.</li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="pimms.lazy_map">
<code class="descclassname">pimms.</code><code class="descname">lazy_map</code><span class="sig-paren">(</span><em>initial={}</em>, <em>pre_size=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.lazy_map" title="Permalink to this definition">¶</a></dt>
<dd><p>lazy_map is a blatant copy of the pyrsistent.pmap function, and is used to create lazy maps.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.is_lazy_map">
<code class="descclassname">pimms.</code><code class="descname">is_lazy_map</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_lazy_map" title="Permalink to this definition">¶</a></dt>
<dd><p>is_lazy_map(m) yields True if m is an instance if LazyPMap and False otherwise.</p>
</dd></dl>

<dl class="class">
<dt id="pimms.LazyPMap">
<em class="property">class </em><code class="descclassname">pimms.</code><code class="descname">LazyPMap</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.LazyPMap" title="Permalink to this definition">¶</a></dt>
<dd><p>LazyPMap is an immutable map that is identical to pyrsistent’s PMap, but that treats functions
of 0 arguments, when values, as lazy values, and memoizes them as it goes.</p>
<dl class="method">
<dt id="pimms.LazyPMap.is_lazy">
<code class="descname">is_lazy</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.LazyPMap.is_lazy" title="Permalink to this definition">¶</a></dt>
<dd><p>lmap.is_lazy(k) yields True if the given k is lazy and unmemoized in the given lazy map,
lmap, otherwise False.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.LazyPMap.is_memoized">
<code class="descname">is_memoized</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.LazyPMap.is_memoized" title="Permalink to this definition">¶</a></dt>
<dd><p>lmap.is_memoized(k) yields True if k is a key in the given lazy map lmap that is both lazy
and already memoized.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.LazyPMap.is_normal">
<code class="descname">is_normal</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.LazyPMap.is_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>lmap.is_normal(k) yields True if k is a key in the given lazy map lmap that is neither lazy
nor a formerly-lazy memoized key.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.LazyPMap.iterlazy">
<code class="descname">iterlazy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pimms.LazyPMap.iterlazy" title="Permalink to this definition">¶</a></dt>
<dd><p>lmap.iterlazy() yields an iterator over the lazy keys only (memoized lazy keys are not
considered lazy).</p>
</dd></dl>

<dl class="method">
<dt id="pimms.LazyPMap.itermemoized">
<code class="descname">itermemoized</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pimms.LazyPMap.itermemoized" title="Permalink to this definition">¶</a></dt>
<dd><p>lmap.itermemoized() yields an iterator over the memoized keys only (neihter unmemoized lazy
keys nor normal keys are considered memoized).</p>
</dd></dl>

<dl class="method">
<dt id="pimms.LazyPMap.iternormal">
<code class="descname">iternormal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pimms.LazyPMap.iternormal" title="Permalink to this definition">¶</a></dt>
<dd><p>lmap.iternormal() yields an iterator over the normal unlazy keys only (memoized lazy keys
are not considered normal).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pimms.is_map">
<code class="descclassname">pimms.</code><code class="descname">is_map</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_map" title="Permalink to this definition">¶</a></dt>
<dd><p>is_map(x) yields True if x implements Python’s builtin Mapping class.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.is_pmap">
<code class="descclassname">pimms.</code><code class="descname">is_pmap</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_pmap" title="Permalink to this definition">¶</a></dt>
<dd><p>is_pmap(x) yields True if x is a persistent map object and False otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.merge">
<code class="descclassname">pimms.</code><code class="descname">merge</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.merge" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>merge(…) lazily collapses all arguments, which must be python Mapping objects of some kind,</dt>
<dd>into a single mapping from left-to-right. The mapping that is returned is a lazy persistent
object that does not request the value of a key from any of the maps provided until they are
requested of it; in this fashion it preserves the laziness of immutable map objects that are
passed to it. Arguments may be mappings or lists/tuples of mappings.</dd>
</dl>
<p>The following options are accepted:
* choose (default None) specifies a function that chooses from which map, of those maps given</p>
<blockquote>
<div>to merge, the value should be drawn when keys overlap. The function is always passed two
arguments: the key for which the conflict occurs and a list of maps containing that key; it
should return the value to which the key should be mapped. The default uses the first map.</div></blockquote>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pimms.</code><code class="descname">is_map</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span></dt>
<dd><p>is_map(x) yields True if x implements Python’s builtin Mapping class.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">pimms.</code><code class="descname">is_pmap</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span></dt>
<dd><p>is_pmap(x) yields True if x is a persistent map object and False otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.is_quantity">
<code class="descclassname">pimms.</code><code class="descname">is_quantity</code><span class="sig-paren">(</span><em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_quantity" title="Permalink to this definition">¶</a></dt>
<dd><p>is_quantity(q) yields True if q is a pint quantity and False otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.is_unit">
<code class="descclassname">pimms.</code><code class="descname">is_unit</code><span class="sig-paren">(</span><em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>is_unit(q) yields True if q is a pint unit and False otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.quant">
<code class="descclassname">pimms.</code><code class="descname">quant</code><span class="sig-paren">(</span><em>val</em>, <em>unit</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.quant" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>quant(value, unit) returns a quantity with the given unit; if value is not currently a quantity,</dt>
<dd>then value * unit is returned; if value is a quantity, then it is coerced into the given unit;
this may raise an error if the units are not compatible.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pimms.mag">
<code class="descclassname">pimms.</code><code class="descname">mag</code><span class="sig-paren">(</span><em>val</em>, <em>unit=Ellipsis</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.mag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>mag(value) returns the magnitide of the given value; if value is not a quantity, then value is</dt>
<dd>returned; if value is a quantity, then its magnitude is returned. If the option unit is given
then, if the val is quantity, it is cast to the given unit before being the magnitude is
returned, otherwise it is returned alone</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pimms.like_units">
<code class="descclassname">pimms.</code><code class="descname">like_units</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.like_units" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>like_units(a,b) yields True if a and b can be cast to each other in terms of units and False</dt>
<dd>otherwise. Non-united units are considered dimensionless units.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pimms.qhashform">
<code class="descclassname">pimms.</code><code class="descname">qhashform</code><span class="sig-paren">(</span><em>o</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.qhashform" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>qhashform(o) yields a version of o, if possible, that yields a hash that can be reproduced</dt>
<dd>across instances. This correctly handles quantities and numpy arrays, among other things.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pimms.qhash">
<code class="descclassname">pimms.</code><code class="descname">qhash</code><span class="sig-paren">(</span><em>o</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.qhash" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>qhash(o) is a hash function that operates like hash(o) but attempts to, where possible, hash</dt>
<dd>quantities in a useful way. It also correctly handles numpy arrays and various other normally
mutable and/or unhashable objects.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pimms.save">
<code class="descclassname">pimms.</code><code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>obj</em>, <em>overwrite=False</em>, <em>create_directories=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.save" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>pimms.save(filename, obj) attempts to pickle the given object obj in the filename (or stream,</dt>
<dd>if given). An error is raised when this cannot be accomplished; the first argument is always
returned; though if the argument is a filename, it may be a differet string that refers to
the same file.</dd>
</dl>
<p>The save/load protocol uses pickle for all saving/loading except when the object is a numpy
object, in which case it is written using obj.tofile(). The save function writes meta-data
into the file so cannot simply be unpickled, but must be loaded using the pimms.load()
function. Fundamentally, however, if an object can be picled, it can be saved/loaded.</p>
<dl class="docutils">
<dt>Options:</dt>
<dd><ul class="first last simple">
<li>overwrite (False) The optional parameter overwrite indicates whether an error should be
raised before opening the file if the file already exists.</li>
<li>create_directories (False) The optional parameter create_directories indicates whether the
function should attempt to create the directories in which the filename exists if they do
not already exist.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pimms.load">
<code class="descclassname">pimms.</code><code class="descname">load</code><span class="sig-paren">(</span><em>filename</em>, <em>ureg='pimms'</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.load" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>pimms.load(filename) loads a pimms-formatted save-file from the given filename, which may</dt>
<dd>optionaly be a string. By default, this function forces all quantities (via the pint
module) to be loaded using the pimms.units unit registry; the option ureg can change
this.</dd>
</dl>
<p>If the filename is not a correctly formatted pimms save-file, an error is raised.</p>
<dl class="docutils">
<dt>Options:</dt>
<dd><ul class="first last simple">
<li>ureg (‘pimms’) specifies the unit-registry to use for ping module units that are loaded
from the files; ‘pimms’ is equivalent to pimms.units. None is equivalent to using the
pint._APP_REGISTRY unit registry.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pimms.immutable">
<code class="descclassname">pimms.</code><code class="descname">immutable</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.immutable" title="Permalink to this definition">¶</a></dt>
<dd><p>The &#64;immutable decorator makes an abstract type out of the decorated class that overloads
__new__ to create interesting behavior consistent with immutable data types. The following
decorators may be used inside of the decorated class to define immutable behavior:</p>
<blockquote>
<div><ul class="simple">
<li>&#64;value indicates that the following function is really a value that should be calculated
and stored as a value of its arguments. The arguments should not start with self and 
should instead be named after other values from which it is calculated. If there are no
arguments, then the returned value is a constant. Note that self is not an argument to this
function.</li>
<li>&#64;param indicates that the following function is really a variable that should be checked
by the decorated function. Params are settable as long as the immutable object is transient.
The check function decorated by &#64;param() is actually a transformation function that is
called every time the parameter gets changed; the actual value given to which the param is
set is the value returned by this function. The function may raise exceptions to flag
errors. Note that self is not an argument to this function. All parameters are required for
an instantiated object; this means that all parameters must either be provided as values or
options of implementing classes or must be assigned in the constructor.</li>
<li>&#64;option(x) indicates that the following function is really an optional value; the syntax and
behavior of &#64;option is identical to &#64;param except that &#64;option(x) indicates that, if not
provided, the parameter should take the value x, while &#64;param indicates that an exception
should be raised.</li>
<li>&#64;require indicates that the following function is a requirement that should be run on the
given arguments (which should name params/options/values of the class). Note that self is
an argument to the function. If the function yields a truthy value, then the requirement is
considered to be met; if it raises an exception or yields a non-trithy value (like None or
[]), then the requirement is not met and the object is considered invalid.</li>
</ul>
</div></blockquote>
<p>In immutable objects, the functions defined by &#64;require decorators are not instantiated; they
may, however, be overloaded and called back to the parent class.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.require">
<code class="descclassname">pimms.</code><code class="descname">require</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.require" title="Permalink to this definition">¶</a></dt>
<dd><p>The &#64;require decorator, usable in an immutable class (see immutable), specifies that the
following function is actually a validation check on the immutable class. These functions
will appear as static members of the class and get called automatically when the relevant
data change. Daughter classes can overload requirements to change them, or may add new
requirements with different function names.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.value">
<code class="descclassname">pimms.</code><code class="descname">value</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.value" title="Permalink to this definition">¶</a></dt>
<dd><p>The &#64;value decorator, usable in an immutable class (see immutable), specifies that the following
function is actually a calculator for a lazy value. The function parameters are the attributes
of the object that are part of the calculation.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.param">
<code class="descclassname">pimms.</code><code class="descname">param</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.param" title="Permalink to this definition">¶</a></dt>
<dd><p>The &#64;param decorator, usable in an immutable class (see immutable), specifies that the following
function is actually a transformation on an input parameter; the parameter is required, and is 
set to the value returned by the function decorated by the parameter; i.e., if you decorate the
function abc with &#64;param, then imm.abc = x will result in imm’s abc attribute being set to the
value of type(imm).abc(x).</p>
</dd></dl>

<dl class="function">
<dt id="pimms.option">
<code class="descclassname">pimms.</code><code class="descname">option</code><span class="sig-paren">(</span><em>default_value</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.option" title="Permalink to this definition">¶</a></dt>
<dd><p>The &#64;option(x) decorator, usable in an immutable class (see immutable), is identical to the
&#64;param decorator except that the parameter is not required and instead takes on the default
value x when the immutable is created.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.is_imm">
<code class="descclassname">pimms.</code><code class="descname">is_imm</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_imm" title="Permalink to this definition">¶</a></dt>
<dd><p>is_imm(obj) yields True if obj is an instance of an immutable class and False otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.is_imm_type">
<code class="descclassname">pimms.</code><code class="descname">is_imm_type</code><span class="sig-paren">(</span><em>cls</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_imm_type" title="Permalink to this definition">¶</a></dt>
<dd><p>is_imm_type(cls) yields True if cls is an immutable class and False otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.imm_copy">
<code class="descclassname">pimms.</code><code class="descname">imm_copy</code><span class="sig-paren">(</span><em>imm</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.imm_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_copy(imm, a=b, c=d…) yields a persisent copy of the immutable object imm that differs from
imm only in that the parameters a, c, etc. have been changed to have the values b, d, etc.
If the object imm is persistent and no changes are made, imm is returned. If imm is transient,
a persistent copy of imm is always made.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.imm_persist">
<code class="descclassname">pimms.</code><code class="descname">imm_persist</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.imm_persist" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_persist(imm) turns imm from a transient into a persistent immutable and returns imm. If imm
is already persistent, then it is simply returned.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.imm_transient">
<code class="descclassname">pimms.</code><code class="descname">imm_transient</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.imm_transient" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_transient(imm) yields a duplicate of the given immutable imm that is transient.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.imm_params">
<code class="descclassname">pimms.</code><code class="descname">imm_params</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.imm_params" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_params(imm) yields a dictionary of the parameters of the immutable object imm.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.imm_values">
<code class="descclassname">pimms.</code><code class="descname">imm_values</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.imm_values" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_values(imm) yields a dictionary of the values of the immutable object imm. Note that this
forces all of the values to be reified, so only use it if you want to force execution of all
lazy values.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.imm_dict">
<code class="descclassname">pimms.</code><code class="descname">imm_dict</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.imm_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_dict(imm) yields a persistent dictionary of the params and values of the immutable
object im. Note that this forces all of the values to be reified, so only use it if you want to
force execution of all lazy values.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.imm_is_persistent">
<code class="descclassname">pimms.</code><code class="descname">imm_is_persistent</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.imm_is_persistent" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_is_persistent(imm) yields True if imm is a persistent immutable object, otherwise False.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.imm_is_transient">
<code class="descclassname">pimms.</code><code class="descname">imm_is_transient</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.imm_is_transient" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_is_transient(imm) yields True if imm is a transient immutable object, otherwise False.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.calc">
<code class="descclassname">pimms.</code><code class="descname">calc</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.calc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>&#64;calc is a decorator that indicates that the function that follows is a calculation component;</dt>
<dd>calculation components can be used to form Plan objects (see Plan). In this
case, the return value is given the same name as the function.</dd>
<dt>&#64;calc(names…) accepts a string or list/tuple of strings that name the output values of the</dt>
<dd>calc function. In this case, the function must return either a tuple of thes values in the
order or a dictionary in which the keys are the same as the given names. In this case, the
optional value lazy=False may be passed after the names to indicate that the calculation
should be run immediately when parameters are set/changed in a calculation rather than lazily
when requested.</dd>
<dt>&#64;calc(None) is a special instance in which the lazy argument is ignored, no efferent values are</dt>
<dd>expected, and the calculation is always run when the afferent parameters are updated.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pimms.plan">
<code class="descclassname">pimms.</code><code class="descname">plan</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.plan" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>plan(name1=calcs1, name2=calc2…) yields a new calculation plan (object of type</dt>
<dd>Plan) that is itself a constructor for the calculation dictionary that is implied by
the given calc functionss given. The names that are given are used as identifiers for
updating the calc plan (using the without and using methods).</dd>
<dt>plan(arg1, arg2…, name1=calc1, name2=calc2…) additionally initializes the dictionary</dt>
<dd>of calculations and names with the calculation plans or dictionaries given as arguments. These
are collapsed left-to-right.</dd>
</dl>
<p>plan(imap) yields the plan object for the given IMap imap.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.imap">
<code class="descclassname">pimms.</code><code class="descname">imap</code><span class="sig-paren">(</span><em>p</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.imap" title="Permalink to this definition">¶</a></dt>
<dd><p>imap(p, args…) yields an immutable map object made from the plan object p and the given
arguments, which may be any number of mappings followed by any number of keyword arguments,
all of which are merged left-to-right then interpreted as the parameters of the given plan p.</p>
</dd></dl>

<dl class="class">
<dt id="pimms.Calc">
<em class="property">class </em><code class="descclassname">pimms.</code><code class="descname">Calc</code><span class="sig-paren">(</span><em>affs</em>, <em>f</em>, <em>effs</em>, <em>dflts</em>, <em>lazy=True</em>, <em>meta_data={}</em>, <em>cache=False</em>, <em>memoize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Calc" title="Permalink to this definition">¶</a></dt>
<dd><p>The Calc class encapsulates data regarding the calculation of a single set of data from a
separate set of input data. The input parameters are referred to as afferent values and the
output variables are referred to as efferent values.</p>
<dl class="method">
<dt id="pimms.Calc.discard_defaults">
<code class="descname">discard_defaults</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Calc.discard_defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>node.discard_defaults(a, b…) yields a new calculation node identical to the given node
except that the default values for the given afferent parameters named by the arguments a,
b, etc. have been removed. In the new node that is returned, these parameters will be
required.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.Calc.remove_defaults">
<code class="descname">remove_defaults</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Calc.remove_defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>node.remove_defaults(a, b…) is identical to node.discard_defaults(a, b…) except that
it raises a KeyError if any of the given arguments are not already defaults.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.Calc.set_defaults">
<code class="descname">set_defaults</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Calc.set_defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>node.set_defaults(a=b…) yields a new calculation node identical to the given node except
with the default values matching the given key-value pairs. Arguments are collapsed left-to
right with later arguments overwriting earlier arguments.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.Calc.set_meta">
<code class="descname">set_meta</code><span class="sig-paren">(</span><em>meta_data</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Calc.set_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>node.set_meta(meta) yields a calculation node identical to the given node except that its
meta_data attribute has been set to the given dictionary meta. If meta is not persistent,
it is cast to a persistent dictionary first.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.Calc.tr">
<code class="descname">tr</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Calc.tr" title="Permalink to this definition">¶</a></dt>
<dd><p>calc_fn.tr(…) yields a copy of calc_fn in which the afferent and efferent values of the
function have been translated. The translation is found from merging the list of 0 or more
dictionary arguments given left-to-right followed by the keyword arguments.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pimms.Plan">
<em class="property">class </em><code class="descclassname">pimms.</code><code class="descname">Plan</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Plan" title="Permalink to this definition">¶</a></dt>
<dd><p>The Plan class encapsulates individual functions that require parameters as inputs and
produce outputs in the form of named values. Plan objects can be called as functions with
a dictionary and/or a list of keyword parameters specifying their parameters; they always return
a dictionary of the values they calculate, even if they calculate only a single value.</p>
<p>The Plan class should not be overloaded and should be instantiated using the &#64;calculates
decorator only; it should not be overloaded directly.</p>
<dl class="method">
<dt id="pimms.Plan.discard">
<code class="descname">discard</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Plan.discard" title="Permalink to this definition">¶</a></dt>
<dd><p>cplan.discard(…) yields a new calculation plan identical to cplan except without any of
the calculation steps listed in the arguments.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.Plan.discard_defaults">
<code class="descname">discard_defaults</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Plan.discard_defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>cplan.discard_defaults(a, b…) yields a new caclulation plan identical to cplan except 
without default values for any of the given parameter names.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.Plan.forget">
<code class="descname">forget</code><span class="sig-paren">(</span><em>node=None</em>, <em>cache_directory=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Plan.forget" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>plan.forget() clears the in-memory memoized cache for the plan and returns the cache dict</dt>
<dd>prior to clearing.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pimms.Plan.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Plan.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>cplan.remove(…) yields a new calculation plan identical to cplan except without any of
the calculation steps listed in the arguments. An exception is raised if any keys are not
found in the calc-plan.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.Plan.remove_defaults">
<code class="descname">remove_defaults</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Plan.remove_defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>cplan.remove_defaults(a, b…) yields a new caclulation plan identical to cplan except 
without default values for any of the given parameter names. An exception is raised if any
default value given is not found in cplan.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.Plan.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Plan.set" title="Permalink to this definition">¶</a></dt>
<dd><p>cplan.set(a=b…) yields a new caclulation plan identical to cplan except such that the
calculation pieces specified by the arguments have been replaced with the given
calculations instead.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.Plan.set_defaults">
<code class="descname">set_defaults</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Plan.set_defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>cplan.set_defaults(a=b…) yields a new caclulation plan identical to cplan except such
that the calculation default values specified by the arguments have been replaced with the
given values instead. E.g., cplan.set_defaults(a=1) would return a new plan with a default
value for a=1.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.Plan.tr">
<code class="descname">tr</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.Plan.tr" title="Permalink to this definition">¶</a></dt>
<dd><p>p.tr(…) yields a copy of plan p in which the afferent and efferent values of all of the
calc functions contained in the plan have been translated. The translation is found from
merging the list of 0 or more dictionary arguments given left-to-right followed by the
keyword arguments.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pimms.IMap">
<em class="property">class </em><code class="descclassname">pimms.</code><code class="descname">IMap</code><span class="sig-paren">(</span><em>plan</em>, <em>afferents</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.IMap" title="Permalink to this definition">¶</a></dt>
<dd><p>The IMap class instantiates a lazy immutable mapping from both parameters and calculated
value names to their values. IMap objects should only be created in two ways:</p>
<blockquote>
<div><ol class="arabic simple">
<li>by passing a calculation plan a complete set of parameters, or,</li>
<li>by calling the using method on an existing IMap to update the parameters.</li>
</ol>
</div></blockquote>
<dl class="method">
<dt id="pimms.IMap.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; D[k] if k in D, else d.  d defaults to None.<a class="headerlink" href="#pimms.IMap.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pimms.IMap.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.IMap.set" title="Permalink to this definition">¶</a></dt>
<dd><p>d.set(…) yields a copy of the IMap object d; the … may be replaced with either
nothing (in which case d is returned) or a list of 0 or more dictionaries followed by a lsit
of zero or more keyword arguments. These dictionaries and keywords arguments are merged
left-to-right; the result may contain only afferent parameters of d and replaces the values
of d in the newly returned calc dictionary.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.IMap.tr">
<code class="descname">tr</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.IMap.tr" title="Permalink to this definition">¶</a></dt>
<dd><p>imap.tr(…) yields a copy of the immutable map imap in which both the plan and the keys of
the new map have been translated according to the translation given in the arguments list.
The translation is found from merging the list of 0 or more dictionary arguments given
left-to-right followed by the keyword arguments.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pimms.is_calc">
<code class="descclassname">pimms.</code><code class="descname">is_calc</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>is_calc(x) yields True if x is a function that was decorated with an &#64;calc directive and False
otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.is_plan">
<code class="descclassname">pimms.</code><code class="descname">is_plan</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_plan" title="Permalink to this definition">¶</a></dt>
<dd><p>is_plan(x) yields True if x is a calculation plan made with the plan function and False
otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.is_imap">
<code class="descclassname">pimms.</code><code class="descname">is_imap</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_imap" title="Permalink to this definition">¶</a></dt>
<dd><p>is_imap(x) yields True if x is an IMap object and False otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pimms.itable">
<code class="descclassname">pimms.</code><code class="descname">itable</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.itable" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>itable(…) yields a new immutable table object from the given set of arguments. The arguments</dt>
<dd>may be any number of maps or itables followed by any number of keyword arguments. All the
entries from the arguments and keywords are collapsed left-to-right (respecting laziness),
and the resulting column set is returned as the itable. Arguments and maps may contain
values that are functions of zero arguments; these are considered lazy values and are not
evaluated by the itable function.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pimms.is_itable">
<code class="descclassname">pimms.</code><code class="descname">is_itable</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.is_itable" title="Permalink to this definition">¶</a></dt>
<dd><p>is_itable(x) yields True if x is an ITable object and False otherwise.</p>
</dd></dl>

<dl class="class">
<dt id="pimms.ITable">
<em class="property">class </em><code class="descclassname">pimms.</code><code class="descname">ITable</code><span class="sig-paren">(</span><em>imm</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable" title="Permalink to this definition">¶</a></dt>
<dd><p>The ITable class is a simple immutable datatable.</p>
<dl class="staticmethod">
<dt id="pimms.ITable.column_names">
<em class="property">static </em><code class="descname">column_names</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.column_names" title="Permalink to this definition">¶</a></dt>
<dd><p>itbl.column_names is a tuple of the names of the columns of the data table.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pimms.ITable.columns">
<em class="property">static </em><code class="descname">columns</code><span class="sig-paren">(</span><em>data</em>, <em>row_count</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.columns" title="Permalink to this definition">¶</a></dt>
<dd><p>itbl.columns is a tuple of the columns in the given datatable itbl. Anything that depends on
columns includes a de-facto check that all columns are the same length.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>imm</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_copy(imm, a=b, c=d…) yields a persisent copy of the immutable object imm that differs from
imm only in that the parameters a, c, etc. have been changed to have the values b, d, etc.
If the object imm is persistent and no changes are made, imm is returned. If imm is transient,
a persistent copy of imm is always made.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pimms.ITable.data">
<em class="property">static </em><code class="descname">data</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.data" title="Permalink to this definition">¶</a></dt>
<dd><p>itbl.data is an immutable map of in which property names are associated with their data
vectors.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.discard">
<code class="descname">discard</code><span class="sig-paren">(</span><em>cols</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.discard" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>itbl.discard(arg) discards either the list of rows, given as ingtegers, or the list of</dt>
<dd>columns, given as strings.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.iterrows">
<code class="descname">iterrows</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.iterrows" title="Permalink to this definition">¶</a></dt>
<dd><p>itbl.iterrows() iterates over the rows of the givan itable itbl.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.map">
<code class="descname">map</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.map" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>itbl.map(f) yields the result of mapping the rows of the given datatable itbl over the</dt>
<dd>given function f.</dd>
</dl>
<p>The function f is called according to its argument spec; generally speaking this assures an
intuitive behavior for most uses of the map method. The exact rules are detailed below:</p>
<blockquote>
<div><ol class="arabic simple">
<li>If the function f accepts a single argument that is either named _ or anything other
than a column name in itbl, the entire row pmap is passed to f as that argument.</li>
<li>Any other valid function signature is allowed to optionally include a variable keyword
argument, which is given the entire row when present. Additionally, variadic arguments
are always simply ignored. Any argument named _ is always given the entire value of
the row.</li>
<li>If f accepts any number of parameters named after columns in itbl, these column values
for each row are passed (with optional keyword argument).</li>
<li>If f accepts additional parameters that are not named after columns but that do have
default values, these defaults are used to fill in the appropriate values.</li>
<li>If f accepts additional named values, they are given the value None.</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.merge" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>itbl.merge(…) yields a copy of the ITable object itbl that has been merged left-to-right</dt>
<dd>with the given arguments.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.params">
<code class="descname">params</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.params" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_params(imm) yields a dictionary of the parameters of the immutable object imm.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.persist">
<code class="descname">persist</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_persist(imm) turns imm from a transient into a persistent immutable and returns imm. If imm
is already persistent, then it is simply returned.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pimms.ITable.row_count">
<em class="property">static </em><code class="descname">row_count</code><span class="sig-paren">(</span><em>data</em>, <em>_row_count</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>itbl.row_count is the number of rows in the given datatable itbl.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pimms.ITable.rows">
<em class="property">static </em><code class="descname">rows</code><span class="sig-paren">(</span><em>data</em>, <em>column_names</em>, <em>row_count</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.rows" title="Permalink to this definition">¶</a></dt>
<dd><p>itbl.rows is a tuple of all the persistent maps that makeup the rows of the data table.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>arg</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.select" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>itbl.select(idcs) yields a sub-table in which only the rows indicated by the given list of</dt>
<dd>indices are kept.</dd>
</dl>
<p>itbl.select(f) keeps all rows for which the function f yields True.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>k</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.set" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>itbl.set(name, val) yields a new itable object identical to the given itbl except that it</dt>
<dd>includes the vector val under the given column name.</dd>
<dt>itbl.set(row, map) updates just the given row to have the properties in the given map; if</dt>
<dd>this results in a new column being added, it will have the value None for all other rows.</dd>
<dt>itbl.set(rows, m) allows a sequence of rows to be set by passing rows as either a list or</dt>
<dd>slice; m may also be a single map or a sequence of maps whose size matches that of rows.
Alternately, m may be an itable whose row-size matches that of rows; in this case new
column names may again be added.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.todict">
<code class="descname">todict</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.todict" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_dict(imm) yields a persistent dictionary of the params and values of the immutable
object im. Note that this forces all of the values to be reified, so only use it if you want to
force execution of all lazy values.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.transient">
<code class="descname">transient</code><span class="sig-paren">(</span><em>imm</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.transient" title="Permalink to this definition">¶</a></dt>
<dd><p>imm_transient(imm) yields a duplicate of the given immutable imm that is transient.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pimms.ITable.validate_data">
<em class="property">static </em><code class="descname">validate_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.validate_data" title="Permalink to this definition">¶</a></dt>
<dd><p>ITable data is required to be a PMap with keys that are strings.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pimms.ITable.validate_row_count">
<em class="property">static </em><code class="descname">validate_row_count</code><span class="sig-paren">(</span><em>_row_count</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.validate_row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>ITable _row_count must be a non-negative integer or None.</p>
</dd></dl>

<dl class="method">
<dt id="pimms.ITable.where">
<code class="descname">where</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#pimms.ITable.where" title="Permalink to this definition">¶</a></dt>
<dd><p>itbl.where(f) yields the indices for which itbl.map(f) yields True.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Noah C. Benson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>