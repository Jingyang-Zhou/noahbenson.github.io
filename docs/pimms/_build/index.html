
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Welcome to Pimms’s documentation! &#8212; Pimms 0.2.3 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-pimms-s-documentation">
<h1>Welcome to Pimms’s documentation!<a class="headerlink" href="#welcome-to-pimms-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<span class="target" id="module-pimms"></span><p>The pimms library is an immutable data-structure toolkit. It works primarily by decorators applied
to classes and their members to declare how an immutable data-structure’s members are related.
Taken together, these decorators form a DSL-like system for declaring immutable data-structures with
full inheritance support.</p>
<p>An immutable data-structure is simply a class that has been modified by the &#64;immutable decorator.
Inside an immutable class, a few things can be declared normally while others must be declared via
the special immutable syntax.
Things that can be delcared normally in an immutable class:</p>
<blockquote>
<div><ul class="simple">
<li>Instance methods of the class (def some_method(self, arg): …)</li>
<li>Static methods of the class (using &#64;staticmethod)</li>
<li>Static members of the class (some_class_member = 10)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Things that cannot be declared normally in an immutable class:</dt>
<dd><ul class="first last simple">
<li>All member variables of a class instance (usually assigned in __init__)</li>
<li>__new__, __setattr__, __getattribute__, __delattr__, __copy__, and __deepcopy__ cannot be
overloaded in immutable classes; doing so will result in undefined behavior</li>
<li>Immutable classes should generally only inherit from object or other immutable classes;
inheritance with other non-immutable classes is fine in theory, especially if only methods are
added to the class, but member access from immutable objects to non-immutable class members is
beyond the scope of this library.</li>
</ul>
</dd>
</dl>
<p>Immutable instance member variables, which are usually simply assigned in the class’s __init__
method, must be declared specially in immutable classes. All immutable instance members fall into
one of two categories: parameters and values. Parameters are values that must be assigned by the
end of the object’s __init__ function, in order for the object to be valid (an exception is raised
if these are not filled). Options are a special kind of parameter that also have default values in
case no assignment is given. Values, unlike parameters, can never be assigned directly; instead,
they are lazily and automatically calculated by a user-provided function of zero or more other
members of the class. Values may depend on either parameters or other values as long as there is
not a circular dependency graph implicit in the declarations.</p>
<p>All such instance member declarations are made using the &#64;param, &#64;option, &#64;value, and &#64;require
decorators, documented briefly here. In all four cases, &#64;param, &#64;option(&lt;default value&gt;), &#64;value,
and &#64;require, the decorator should precede a static function definition.</p>
<blockquote>
<div><ul class="simple">
<li>&#64;param declares two things: first, that the name of the static function that follows it is an
instance member and required parameter of the class and, second, that the static function
itself, which must take exactly one argument, should be considered a translation function on
any value assigned to the object; the return value of the function is the value actually
assigned to the object before any checks are run.</li>
<li>&#64;option(&lt;default value&gt;) is identical to &#64;param except that it declares that the given default
value should be used if no value is assigned to the object in the __init__ method. This value,
if it is used, is not passed through the translation function that follows.</li>
<li>&#64;value declares three things: first, that the name of the static function that follows it is an
instance member and (lazy) value of the class; second, that the arguments to that static
function, which must be named exactly after other instance members of the class, are instance on
members on which this value depends (thus this value will be reset when those members change);
and third, that the return value of that static function, when given the appropriate member
values, should be the value assigned to the instance member when requested.</li>
<li>&#64;require declares three things: first, that the name of the following static function is the
identifier for a particular requirement check on the instance members of any object of this
class; second, that the parameters of that static function, which must match exactly the names
of other instance members of the class, are the instance members that this requirement checks;
and third, that the static function’s return value will be True if and only if the check is
passed. The requirement function may throw its own exception or return False, in which case a
generic exception is raised.</li>
</ul>
</div></blockquote>
<p>All four decorator types may be overloaded in immutable child classes. Overloading works much as it
does with normal methods; only the youngest child-class’s method is required. This can be used to
overload requirements, but new requirements can be placed to act as additional constraints; i.e.,
the youngest class’s requirement is always run for all requirements in an object’s entire class
hierarchy when a relevant instance members is updated. Overloading may also be used to change an
instance member’s type in the child class, such as from a value to a parameter or vice versa. The
child class must, of course, be free of circular dependencies despite these rearrangements.</p>
<p>Note that a required parameter may be implied by the other instance member declarations; this is not
an error and instead inserts the parameter into the class automatically with no translation
function. This occurs when either a value or a requirement declares the parameter as an argument
but no instance member with the parameter’s name appears elsewhere in the class or its ancestor
classes. This can be used to create a sort of abstract immutable base class, in that a class may
declare a requirement of some parameter that is not otherwise defined; in order to instantiate the
class, that parameter must be given, either in a child class’s __init__ method or as a value or an
explicit (required or optional) parameter.</p>
<p>When an immutable object is constructed, it begins its life in a special ‘init’ state; this state is
unique in that no requirement checks are run until either the __init__ method returns or a value is
requested of the object; at that point, all non-optional parameters must be specified or an
exception is raised. If all parameters were set, then all requirement checks are run and the
object’s state shifts to ‘transient’. An immutable object imm can be tested for transience by using
the method imm.is_transient(). A transient object allows its parameters (but never its values) to be
set using normal setattr (imm.x = y) syntax. Requirement checks that are related to a parameter are
changed every time that parameter is set, after the translation function for that parameter is used.
An immutable object remains in the transient state until it is persisted via the imm.persist()
method. Once an object is persistent, it cannot be updated via setattr mechanisms and should be
considered permanent. A new transient duplicate of the object may be created using the
imm.transient() method (this may also be used while the object is still transient). To update the
values of an immutable object, the imm.copy(param1=val1, param2=val2, …) method should be used.
This method returns a persistent duplicate of the immutable object imm with the given parameters
updated to the given values; these values are always passed through the translation functions
and all relevant chacks are run prior to the return of the copy function. The copy function may
be called on transient or persistent immutables, but the return value is always peresistent.</p>
<dl class="docutils">
<dt>The additional utility functions are provided as part of the pimms package:</dt>
<dd><ul class="first last simple">
<li>is_imm(x) yields True if x is an object that is an instance of an immutable class and False
otherwise.</li>
<li>is_imm_type(x) yields True if x is a class that is immutable and False otherwise.</li>
<li>imm_copy(imm, …) is identical to imm.copy(…) for an immutable object imm.</li>
<li>imm_persist(imm) is identical to imm.persist() for a transient immutable object imm.</li>
<li>imm_transient(imm) is identical to imm.transient() for an immutable object imm.</li>
<li>imm_values(imm_t) yields a list of the values of the immutable class imm_t.</li>
<li>imm_params(imm_t) yields a list of the parameters of the immutable class imm_t.</li>
<li>imm_dict(imm) is identical to imm.asdict() for an immutable object imm.</li>
<li>imm_is_persistent(imm) is identical to imm.is_persistent() for an immutable object imm.</li>
<li>imm_is_transient(imm) is identical to imm.is_transient() for an immutable object imm.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Noah C. Benson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>